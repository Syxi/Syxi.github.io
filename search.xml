<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多态</title>
      <link href="/2019/11/09/duo-tai/"/>
      <url>/2019/11/09/duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是多态"><a href="#1-什么是多态" class="headerlink" title="1.什么是多态"></a>1.什么是多态</h2><blockquote><p>多态是同一行为具有不同表现形式或形态的能力。即对象多种表现形式的体现，就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时的不确定，而是在程序运行期间确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底时哪个类中实现的方法，必须在由程序运行期间才能决定。</p></blockquote><h2 id="2-多态通俗的简介"><a href="#2-多态通俗的简介" class="headerlink" title="2.多态通俗的简介"></a>2.多态通俗的简介</h2><blockquote><p> 多态就是事物存在的多种形态，比如你在大街上看见一只藏獒，你可以说这只藏獒真凶猛，也可以说这只狗真凶猛，还可以说这个动物真凶猛，以上三种说法其实都是指的这只藏獒。</p><p>  在Java里面，也是存在多态的，只要全部符合下面这三种情况，就是多态 </p><ul><li>有继承</li><li>有重写方法</li><li>有父类引用指向子类对象</li></ul></blockquote><h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h2><h3 id="3-1父类Animal"><a href="#3-1父类Animal" class="headerlink" title="3.1父类Animal"></a>3.1父类Animal</h3><pre><code>public class Animal {    public int age = 10;    public void eat() {        System.out.println(&quot;动物父类&quot;);    }}</code></pre><h3 id="3-2子类Cat"><a href="#3-2子类Cat" class="headerlink" title="3.2子类Cat"></a>3.2子类Cat</h3><pre><code>public class Cat extends Animal {    public int age = 5;    @Override    public void eat() {        System.out.println(&quot;猫吃老鼠&quot;);    }    // Cat类自己的方法    public void sleep() {        System.out.println(&quot;猫在睡觉&quot;);    }}</code></pre><h3 id="3-3测试类"><a href="#3-3测试类" class="headerlink" title="3.3测试类"></a>3.3测试类</h3><pre><code>public class AnimalTest {    public static void main(String[] args) {        Cat cat = new Cat();        cat.eat();        System.out.println(&quot;猫的年龄是：&quot; + cat.age);        // 父类引用指向子类对象        Animal animal = new Cat();        animal.eat();        // 想执行Cat中的sleep()方法，需要向下强制转型        ((Cat) animal).sleep();        // 父类引用访问成员变量        System.out.println(&quot;动物的年龄：&quot; + animal.age);    }}</code></pre><h3 id="3-4测试结果"><a href="#3-4测试结果" class="headerlink" title="###3.4测试结果"></a>###3.4测试结果</h3><pre><code>猫吃老鼠猫的年龄是：5猫吃老鼠猫在睡觉动物的年龄：10</code></pre><h2 id="4-总结分析"><a href="#4-总结分析" class="headerlink" title="4.总结分析"></a>4.总结分析</h2><blockquote><p><strong>父类引用执行方法调用：</strong> 父类 父类的引用 = (指向) 子类的实例</p><p>当父类的引用要执行方法1的时候，他只会跟他指向的对象说，“嗨，哥们，执行一下你的方法1”然后他就不管了，继续睡大觉去了。然后真实的对象实例就会低头看看写在自己身上的方法1，捏出来执行一把。这个时候如果子类对象重写了方法1，捏出来的就是重写的方法。如果没重写，就会找他爸，从他爸身上去捏方法1出来。这就是所谓的<strong>动态绑定</strong>。</p></blockquote><blockquote><p><strong>成员属性的特别之处</strong></p><p> 如果父类、子类定义了相同名字的成员属性， 只取决于<strong>引用的定义类型。</strong>比如Animal的年龄初始化是10，Cat的年龄的初始化是5 </p><p>父类 obj = new 子类()；// obj.age == 5</p><p>子类 obj2 = new 子类()；// obj.age == 10</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2019/11/09/fan-xing/"/>
      <url>/2019/11/09/fan-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2019/11/08/lei/"/>
      <url>/2019/11/08/lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><blockquote><p>定义：类是一组相关的属性和行为的集合，类一般都是泛指某一种事物。</p><p>实例对象：对象就是该事物的具体表现。</p></blockquote><h2 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2.内部类"></a>2.内部类</h2><blockquote><p>定义：在一个类的内部定义另外一个类。</p><p>特点：内部类可以直接访问外部类的成员，包括private修饰的变量和方法。</p></blockquote><ul><li>静态内部类</li><li>匿名内部类</li><li>成员内部类</li><li>局部内部类</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一切皆对象</title>
      <link href="/2019/11/08/java-yi-qie-jie-dui-xiang/"/>
      <url>/2019/11/08/java-yi-qie-jie-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象编程思想"><a href="#1-面向对象编程思想" class="headerlink" title="1.面向对象编程思想"></a>1.面向对象编程思想</h2><blockquote><p>把所有的有形或无形的事物都看作对象，并给对象赋予相应的属性和行为，建立对象之间的联系，使程序更加立体、形象地解决编程领域的问题。</p></blockquote><h2 id="2-类的关系"><a href="#2-类的关系" class="headerlink" title="2.类的关系"></a>2.类的关系</h2><table><thead><tr><th>类的关系</th><th>描述</th><th>具体实现</th></tr></thead><tbody><tr><td>继承</td><td>父类与子类的关系</td><td>extends ( is-a )</td></tr><tr><td>实现</td><td>接口与实现类之间的关系</td><td>implements ( can-do )</td></tr><tr><td>组合</td><td>整体和部分的同生共死的关系，两者完全不可分，具有相同的生命周期</td><td>类是成员变量 ( contains-a )</td></tr><tr><td>聚合</td><td>整体和部分暂时组合在一起，两者可独立存在</td><td>类是成员变量 ( has -a )</td></tr><tr><td>依赖</td><td>一个类用到另外一个类</td><td>import类 ( use -a )</td></tr></tbody></table><blockquote><p>类关系中的组合是一种完全绑定的关系，所有成员共同完成一件使命，它们的生命周期是一样的。组合体现的是整体和部分的关系，同生共死，部分不能在整体之间共享。</p></blockquote><blockquote><p>聚合是一种可以拆分的整体和部分的关系，是一种非常松散的暂时组合，部分可以拆出来给另一个整体。</p></blockquote><blockquote><p>依赖是除组合和聚合的类与类之间的关系，这个类只要import，那就是依赖关系。</p></blockquote><h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h2><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}</code></pre><pre><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;{// 抽象方法，没有方法体 abstract public E get(int index);// 普通方法public boolean add(E e) {        add(size(), e);        return true;    }}</code></pre><blockquote><p>抽象类是对同类事物相对具体的抽象，通常包括抽象方法、普通方法、属性变量。抽象类是对整个类抽象，包括类的属性和行为。设计抽象类是自下而上的过程，我子类需要，所以我定义抽象类。</p></blockquote><h2 id="4接口"><a href="#4接口" class="headerlink" title="4接口"></a>4接口</h2><pre><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {// 抽象方法 int size(); // 默认方法，@since 1.8    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})    default void sort(Comparator&lt;? super E&gt; c) {        Object[] a = this.toArray();        Arrays.sort(a, (Comparator) c);        ListIterator&lt;E&gt; i = this.listIterator();        for (Object e : a) {            i.next();            i.set((E) e);        }    }    // 静态方法 接口的静态方法只能由接口来调用，它不属于实现了那个接口接口的对象，对象调用不到。    static void staticSuYan() {    System.out.println(&quot;接口中的静态方法&quot;)    }    // 接口中成员变量默认是public static final,可以省略这些修饰符    public static final int susu = 20;}</code></pre><blockquote><p>设计接口是自上而下的过程，我接口规范某一行为，我某类需要这个行为，我实现某接口。</p></blockquote><h2 id="5-抽象类和接口的相同点和不同的"><a href="#5-抽象类和接口的相同点和不同的" class="headerlink" title="5.抽象类和接口的相同点和不同的"></a>5.抽象类和接口的相同点和不同的</h2><blockquote><ul><li>在java中，抽象类和接口都不能直接进行实例化，如果要实例化，抽象类引用变量必须指向实现所有抽象方法的子类对象。接口引用变量必须指向实现所有接口方法的类对象。</li><li>抽象类要被子类继承，接口要被类实现。</li><li>接口只能做方法的声明，抽象类既可以做方法声明，还可以做方法实现。</li><li>类只能单继承。</li><li>类或接口可以继承接口，并且可以继承多个接口。</li><li>接口要被类实现，类可以实现多个接口。</li><li>接口中的变量只能是静态的公共变量，抽象类中的变量是普通的变量，即常量。 </li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
