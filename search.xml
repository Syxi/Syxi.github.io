<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java一切皆对象</title>
      <link href="/2019/11/08/java-yi-qie-jie-dui-xiang/"/>
      <url>/2019/11/08/java-yi-qie-jie-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象编程思想"><a href="#1-面向对象编程思想" class="headerlink" title="1.面向对象编程思想"></a>1.面向对象编程思想</h2><blockquote><p>把所有的有形或无形的事物都看作对象，并给对象赋予相应的属性和行为，建立对象之间的联系，使程序更加立体、形象地解决编程领域的问题。</p></blockquote><h2 id="2-类的关系"><a href="#2-类的关系" class="headerlink" title="2.类的关系"></a>2.类的关系</h2><table><thead><tr><th>类的关系</th><th>描述</th><th>具体实现</th></tr></thead><tbody><tr><td>继承</td><td>父类与子类的关系</td><td>extends ( is-a )</td></tr><tr><td>实现</td><td>接口与实现类之间的关系</td><td>implements ( can-do )</td></tr><tr><td>组合</td><td>整体和部分的同生共死的关系，两者完全不可分，具有相同的生命周期</td><td>类是成员变量 ( contains-a )</td></tr><tr><td>聚合</td><td>整体和部分暂时组合在一起，两者可独立存在</td><td>类是成员变量 ( has -a )</td></tr><tr><td>依赖</td><td>一个类用到另外一个类</td><td>import类 ( use -a )</td></tr></tbody></table><p>类关系中的组合是一种完全绑定的关系，所有成员共同完成一件使命，它们的生命周期是一样的。组合体现的是整体和部分的关系，同生共死，部分不能在整体之间共享。</p><p>聚合是一种可以拆分的整体和部分的关系，是一种非常松散的暂时组合，部分可以拆出来给另一个整体。</p><p>依赖是除组合和聚合的类与类之间的关系，这个类只要import，那就是依赖关系。</p><h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h2><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}</code></pre><pre><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;{// 抽象方法，没有方法体 abstract public E get(int index);// 普通方法public boolean add(E e) {        add(size(), e);        return true;    }}</code></pre><p>抽象类是对同类事物相对具体的抽象，通常包括抽象方法、普通方法、属性变量。抽象类是对整个类抽象，包括类的属性和行为。设计抽象类是自下而上的过程，我子类需要，所以我定义抽象类。</p><h2 id="4接口"><a href="#4接口" class="headerlink" title="4接口"></a>4接口</h2><pre><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {// 抽象方法 int size(); // 默认方法，@since 1.8    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})    default void sort(Comparator&lt;? super E&gt; c) {        Object[] a = this.toArray();        Arrays.sort(a, (Comparator) c);        ListIterator&lt;E&gt; i = this.listIterator();        for (Object e : a) {            i.next();            i.set((E) e);        }    }    // 静态方法 接口的静态方法只能由接口来调用，它不属于实现了那个接口接口的对象，对象调用不到。    static void staticSuYan() {    System.out.println(&quot;接口中的静态方法&quot;)    }    // 接口中成员变量默认是public static final,可以省略这些修饰符    public static final int susu = 20;}</code></pre><p>设计接口是自上而下的过程，我接口规范某一行为，我某类需要这个行为，我实现某接口。类或接口可以继承多个接口，类可以实现多个接口。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
