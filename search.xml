<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>覆写与重载</title>
      <link href="/2019/11/12/fu-xie-yu-chong-zai/"/>
      <url>/2019/11/12/fu-xie-yu-chong-zai/</url>
      
        <content type="html"><![CDATA[<p>##覆写</p><blockquote><p>如果父类定义的方法达不到子类的期望，那么子类可以重新实现方法覆盖父类的实现。</p></blockquote><pre><code>public class Father {    public static void main(String[] args) {        Father father = new Son();        father.good();    }    protected void good() {        System.out.println(&quot;叫爸爸&quot;);    }}</code></pre><pre><code>public class Son extends Father {    @Override    public void good() {        System.out.println(&quot;祖安&quot;);    }}</code></pre><h2 id="覆写总结"><a href="#覆写总结" class="headerlink" title="覆写总结"></a>覆写总结</h2><blockquote><p><strong>一大两小两同</strong></p><ul><li><strong>一大</strong>：子类的方法访问权限控制符只能相同或变大。</li><li><strong>两小</strong>：子类抛出异常和方法返回值只能变小（或相同），都能够转型成父类对象。子类的返回值、抛出异常，与父类存在继承关系。</li><li><strong>两同</strong>：方法名和参数必须完全相同。</li></ul></blockquote><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><blockquote><p>在同一个类中，如果多个方法有相同的名字，不同的参数（参数个数、顺序、类型不同），即称为重载。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 覆写 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="/2019/11/10/string-lei/"/>
      <url>/2019/11/10/string-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><blockquote><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串 。</p></blockquote><h2 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h2><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    // String本质是一个char数组，1.9后变成byte数组,节省内存空间的开辟    private final char value[];}</code></pre><blockquote><p> 首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段value是个char[ ]数组，而且是用final修饰的。final修饰的字段创建以后就不可改变。 </p></blockquote><blockquote><p> 有的人以为故事就这样完了，其实没有。因为虽然value是不可变，也只是value这个引用地址不可变。挡不住Array数组是可变的事实 。 也就是说Array变量只是stack上的一个引用，数组的本体结构在heap堆。String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。 </p></blockquote><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><blockquote><p>我们声明的字符串会放到一个叫做字符串常量池的地方，这样可以减少内存在使用，字符串常量池是堆的一部分。<strong>使用字符串常量池</strong>。<strong>每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串</strong></p></blockquote><pre><code>public class StringTest {    public static void main(String[] args) {        // Java 程序中的所有字符串字面值（如&quot;suyan&quot;）都作为String的对象。        String s1 = &quot;suYan&quot;;        String s2 = &quot;suYan&quot;;        // 不建议这种写法，浪费堆内存        String s3 = new String(&quot;suYan&quot;);        String s4 = new String(&quot;allRight&quot;);        System.out.println(s1 == s2);        System.out.println(s1 == s3);        // String类重写了equals()方法，比较的是两个对象的内容        System.out.println(s1.equals(s3));    }}</code></pre><pre><code>truefalsetrueProcess finished with exit code 0</code></pre><h2 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h2><pre><code>public class StringTest {    public static void main(String[] args) {        String s = &quot;suYan&quot;;        // char charAt(int index); 获取index位置的字符        System.out.println(s.charAt(3));        // boolean contains(CharSequence s); 判断字符串是否包含某个字符串        System.out.println(s.contains(&quot;suY&quot;));        // boolean endsWith(String endStr); 判断是否是已某个字符串结尾        System.out.println(s.endsWith(&quot;an&quot;));        // boolean equalsIgnoreCase(String anotherString); 忽略大小写比较两个字符串是否相等        System.out.println(s.equalsIgnoreCase(&quot;sUYAn&quot;));        // byte getBytes(); 转换成byte数组        String s1 = &quot;goodBoy&quot;;        byte [] array1 = s1.getBytes();        for (int i=0; i &lt; array1.length;i++) {            System.out.println(array1[i] + &quot; &quot;);        }        // int indexOf(); 取指定字符在字符串中的位置        System.out.println(s1.indexOf(&quot;B&quot;));        // int indexOf(String str, int fromIndexOf);从指定的下标开始取得指定字符在字符串的位置        System.out.println(s1.indexOf(&quot;y&quot;,1));        // int lastIndexOf(String str); 从后面开始取得指定字符在字符串最后出现的位置        System.out.println(s1.lastIndexOf(&quot;o&quot;));        // int lastIndexOf(String str, int fromIndex); 从后面指定的下标开始取得指定字符在字符串最后出现的位置        System.out.println(s1.lastIndexOf(&quot;d&quot;,5));        // int length()获取字符串的长度        System.out.println(s1.length());        String s2 = &quot;hello&quot;;        // String replaceALL(String str1 String str2); str2替换字符串中str1的内容        System.out.println(s2.replaceAll(&quot;llo&quot;,&quot;www&quot;));        // String[] split(String s); 根据指定的表达式拆分字符串        String s3 = &quot;a,b,c,d&quot;;        String[] array2 = s3.split(&quot;,&quot;);        for (int i=0; i &lt; array2.length;i++) {            System.out.println(array2[i] + &quot; &quot;);        }        // boolean startsWith(String s); 判断是否以某个字符串开始        System.out.println(s2.startsWith(&quot;he&quot;));        // String substring(int begin); 根据传入的索引位置截取字符串        System.out.println(s2.substring(2));        // String substring(int beginIndex, int endIndex); 根据传入的起始和结束位置截字符串        System.out.println(s2.substring(0,3));        // char[] toCharArray(); 将字符串转换为char数组        String s5 = &quot;eclipse&quot;;        char[] array3 = s5.toCharArray();        for (int i=0; i &lt; array3.length;i++) {            System.out.println(array3[i] + &quot; &quot;);        }        // void toUpperCase();转换成大写        System.out.println(s2.toUpperCase());        // void toLowerCase(); 转换成小写        System.out.println(s2.toLowerCase());        // String trim(); 去除首尾空格        String s4 = &quot; may &quot;;        System.out.println(s4.trim());        // String valueOf(Object ob); 将其他类型转换为字符串类型        Object ob = new Object();        ob = null;        // System.out.println(ob.toString()); 报空指针异常        System.out.println(String.valueOf(ob));    }}</code></pre><pre><code>代码运行结果：atruetruetrue103 111 111 100 66 111 121 46537hewwwa b c d truellohele c l i p s e HELLOhellomaynullProcess finished with exit code 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2019/11/09/duo-tai/"/>
      <url>/2019/11/09/duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是多态"><a href="#1-什么是多态" class="headerlink" title="1.什么是多态"></a>1.什么是多态</h2><blockquote><p>多态是同一行为具有不同表现形式或形态的能力。即对象多种表现形式的体现，就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时的不确定，而是在程序运行期间确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底时哪个类中实现的方法，必须在由程序运行期间才能决定。</p></blockquote><h2 id="2-多态通俗的简介"><a href="#2-多态通俗的简介" class="headerlink" title="2.多态通俗的简介"></a>2.多态通俗的简介</h2><blockquote><p> 多态就是事物存在的多种形态，比如你在大街上看见一只藏獒，你可以说这只藏獒真凶猛，也可以说这只狗真凶猛，还可以说这个动物真凶猛，以上三种说法其实都是指的这只藏獒。</p><p>  在Java里面，也是存在多态的，只要全部符合下面这三种情况，就是多态 </p><ul><li>有继承</li><li>有重写方法</li><li>有父类引用指向子类对象</li></ul></blockquote><h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h2><h3 id="3-1父类Animal"><a href="#3-1父类Animal" class="headerlink" title="3.1父类Animal"></a>3.1父类Animal</h3><pre><code>public class Animal {    public int age = 10;    public void eat() {        System.out.println(&quot;动物父类&quot;);    }}</code></pre><h3 id="3-2子类Cat"><a href="#3-2子类Cat" class="headerlink" title="3.2子类Cat"></a>3.2子类Cat</h3><pre><code>public class Cat extends Animal {    public int age = 5;    @Override    public void eat() {        System.out.println(&quot;猫吃老鼠&quot;);    }    // Cat类自己的方法    public void sleep() {        System.out.println(&quot;猫在睡觉&quot;);    }}</code></pre><h3 id="3-3测试类"><a href="#3-3测试类" class="headerlink" title="3.3测试类"></a>3.3测试类</h3><pre><code>public class AnimalTest {    public static void main(String[] args) {        Cat cat = new Cat();        cat.eat();        System.out.println(&quot;猫的年龄是：&quot; + cat.age);        // 父类引用指向子类对象        Animal animal = new Cat();        animal.eat();        // 想执行Cat中的sleep()方法，需要向下强制转型        ((Cat) animal).sleep();        // 父类引用访问成员变量        System.out.println(&quot;动物的年龄：&quot; + animal.age);    }}</code></pre><h3 id="3-4测试结果"><a href="#3-4测试结果" class="headerlink" title="###3.4测试结果"></a>###3.4测试结果</h3><pre><code>猫吃老鼠猫的年龄是：5猫吃老鼠猫在睡觉动物的年龄：10</code></pre><h2 id="4-总结分析"><a href="#4-总结分析" class="headerlink" title="4.总结分析"></a>4.总结分析</h2><blockquote><p><strong>父类引用执行方法调用：</strong> 父类 父类的引用 = (指向) 子类的实例</p><p>当父类的引用要执行方法1的时候，他只会跟他指向的对象说，“嗨，哥们，执行一下你的方法1”然后他就不管了，继续睡大觉去了。然后真实的对象实例就会低头看看写在自己身上的方法1，捏出来执行一把。这个时候如果子类对象重写了方法1，捏出来的就是重写的方法。如果没重写，就会找他爸，从他爸身上去捏方法1出来。这就是所谓的<strong>动态绑定</strong>。</p></blockquote><blockquote><p><strong>成员属性的特别之处</strong></p><p> 如果父类、子类定义了相同名字的成员属性， 只取决于<strong>引用的定义类型。</strong>比如Animal的年龄初始化是10，Cat的年龄的初始化是5 </p><p>父类 obj = new 子类()；// obj.age == 5</p><p>子类 obj2 = new 子类()；// obj.age == 10</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2019/11/09/fan-xing/"/>
      <url>/2019/11/09/fan-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2019/11/08/lei/"/>
      <url>/2019/11/08/lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><blockquote><p>定义：类是一组相关的属性和行为的集合，类一般都是泛指某一种事物。</p><p>实例对象：对象就是该事物的具体表现。</p></blockquote><h2 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2.内部类"></a>2.内部类</h2><blockquote><p>定义：在一个类的内部定义另外一个类。</p><p>特点：内部类可以直接访问外部类的成员，包括private修饰的变量和方法。</p></blockquote><ul><li>静态内部类</li><li>匿名内部类</li><li>成员内部类</li><li>局部内部类</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一切皆对象</title>
      <link href="/2019/11/08/java-yi-qie-jie-dui-xiang/"/>
      <url>/2019/11/08/java-yi-qie-jie-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象编程思想"><a href="#1-面向对象编程思想" class="headerlink" title="1.面向对象编程思想"></a>1.面向对象编程思想</h2><blockquote><p>把所有的有形或无形的事物都看作对象，并给对象赋予相应的属性和行为，建立对象之间的联系，使程序更加立体、形象地解决编程领域的问题。</p></blockquote><h2 id="2-类的关系"><a href="#2-类的关系" class="headerlink" title="2.类的关系"></a>2.类的关系</h2><table><thead><tr><th>类的关系</th><th>描述</th><th>具体实现</th></tr></thead><tbody><tr><td>继承</td><td>父类与子类的关系</td><td>extends ( is-a )</td></tr><tr><td>实现</td><td>接口与实现类之间的关系</td><td>implements ( can-do )</td></tr><tr><td>组合</td><td>整体和部分的同生共死的关系，两者完全不可分，具有相同的生命周期</td><td>类是成员变量 ( contains-a )</td></tr><tr><td>聚合</td><td>整体和部分暂时组合在一起，两者可独立存在</td><td>类是成员变量 ( has -a )</td></tr><tr><td>依赖</td><td>一个类用到另外一个类</td><td>import类 ( use -a )</td></tr></tbody></table><blockquote><p>类关系中的组合是一种完全绑定的关系，所有成员共同完成一件使命，它们的生命周期是一样的。组合体现的是整体和部分的关系，同生共死，部分不能在整体之间共享。</p></blockquote><blockquote><p>聚合是一种可以拆分的整体和部分的关系，是一种非常松散的暂时组合，部分可以拆出来给另一个整体。</p></blockquote><blockquote><p>依赖是除组合和聚合的类与类之间的关系，这个类只要import，那就是依赖关系。</p></blockquote><h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h2><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}</code></pre><pre><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;{// 抽象方法，没有方法体 abstract public E get(int index);// 普通方法public boolean add(E e) {        add(size(), e);        return true;    }}</code></pre><blockquote><p>抽象类是对同类事物相对具体的抽象，通常包括抽象方法、普通方法、属性变量。抽象类是对整个类抽象，包括类的属性和行为。设计抽象类是自下而上的过程，我子类需要，所以我定义抽象类。</p></blockquote><h2 id="4接口"><a href="#4接口" class="headerlink" title="4接口"></a>4接口</h2><pre><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {// 抽象方法 int size(); // 默认方法，@since 1.8    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})    default void sort(Comparator&lt;? super E&gt; c) {        Object[] a = this.toArray();        Arrays.sort(a, (Comparator) c);        ListIterator&lt;E&gt; i = this.listIterator();        for (Object e : a) {            i.next();            i.set((E) e);        }    }    // 静态方法 接口的静态方法只能由接口来调用，它不属于实现了那个接口接口的对象，对象调用不到。    static void staticSuYan() {    System.out.println(&quot;接口中的静态方法&quot;)    }    // 接口中成员变量默认是public static final,可以省略这些修饰符    public static final int susu = 20;}</code></pre><blockquote><p>设计接口是自上而下的过程，我接口规范某一行为，我某类需要这个行为，我实现某接口。</p></blockquote><h2 id="5-抽象类和接口的相同点和不同的"><a href="#5-抽象类和接口的相同点和不同的" class="headerlink" title="5.抽象类和接口的相同点和不同的"></a>5.抽象类和接口的相同点和不同的</h2><blockquote><ul><li>在java中，抽象类和接口都不能直接进行实例化，如果要实例化，抽象类引用变量必须指向实现所有抽象方法的子类对象。接口引用变量必须指向实现所有接口方法的类对象。</li><li>抽象类要被子类继承，接口要被类实现。</li><li>接口只能做方法的声明，抽象类既可以做方法声明，还可以做方法实现。</li><li>类只能单继承。</li><li>类或接口可以继承接口，并且可以继承多个接口。</li><li>接口要被类实现，类可以实现多个接口。</li><li>接口中的变量只能是静态的公共变量，抽象类中的变量是普通的变量，即常量。 </li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
