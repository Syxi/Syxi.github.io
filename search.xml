<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中的迭代器</title>
      <link href="/2019/11/13/java-zhong-de-die-dai-qi/"/>
      <url>/2019/11/13/java-zhong-de-die-dai-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Iterator"><a href="#1-Iterator" class="headerlink" title="1.Iterator"></a>1.Iterator</h2><blockquote><p>  迭代器是一种模式、详细可见其设计模式，可以使得序列类型的数据结构的遍历行为与被遍历的对象分离，即我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象,使用迭代器就可以遍历这个对象的内部。  </p></blockquote><h2 id="2-语法结构"><a href="#2-语法结构" class="headerlink" title="2.语法结构"></a>2.语法结构</h2><blockquote><pre><code>Ierator&lt;类型&gt; 迭代器名 = 集合名.iterator(); // 创建迭代器while(迭代器名.hasNext()) {    语句}</code></pre><h2 id="3-Iterator接口源码"><a href="#3-Iterator接口源码" class="headerlink" title="3.Iterator接口源码"></a>3.Iterator接口源码</h2></blockquote><pre><code>public interface Iterator&lt;E&gt; {boolean hasNext(); // 如果迭代器指向位置后面还有元素，则返回 true，否则返回falsenext(); // 返回集合中Iterator指向位置后面的元素// 删除集合中Iterator指向位置后面的元素default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }</code></pre><h2 id="4-Iterator实例代码"><a href="#4-Iterator实例代码" class="headerlink" title="4.Iterator实例代码"></a>4.Iterator实例代码</h2><pre><code>public class PersonTest {    public static void main(String[] args) {        // 创建集合        ArrayList&lt;Person&gt; a = new ArrayList&lt;&gt;();        // 添加对象        a.add(new Person(&quot;苏彦&quot;, 20));        a.add(new Person(&quot;苏小彦&quot;, 21));        a.add(new Person(&quot;苏大彦&quot;, 22));        a.add(new Person(&quot;苏好彦&quot;, 23));        System.out.println(&quot;遍历集合：&quot;);        // 创建迭代器        Iterator iter = a.iterator();        // 遍历        while(iter.hasNext()) {           // 向下转型            Person temp = (Person)iter.next();             System.out.println(temp.getName() + &quot; &quot; + temp.getAge());        }    }}遍历集合：苏彦 20苏小彦 21苏大彦 22苏好彦 23</code></pre><h2 id="5-Iterator总结"><a href="#5-Iterator总结" class="headerlink" title="5.Iterator总结"></a>5.Iterator总结</h2><blockquote><ul><li>Iterator只能单向移动。 </li><li>不可以在迭代的时候进行集合元素（指的一整个对象元素，不是指对象的属性）的删除和插入，如果想删除元素有一个办法，用迭代器的remove方法删除，但是绝不能插入，直接报错。 </li></ul></blockquote><h2 id="6-ListIterator"><a href="#6-ListIterator" class="headerlink" title="6.ListIterator"></a>6.ListIterator</h2><p> ListIterator是一个功能更加强大的, 它继承于Iterator接口,只能用于各种List类型的访问。 </p><pre><code>public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {    // 以正向遍历列表时，如果列表迭代器后面还有元素，则返回 true，否则返回false    boolean hasNext();    // 返回列表中ListIterator指向位置后面的元素    next();    // 如果以逆向遍历列表，列表迭代器前面还有元素，则返回 true，否则返回false    boolean hasPrevious();    // 返回列表中ListIterator指向位置前面的元素    previous();    // 返回列表中ListIterator所需位置后面元素的索引    int nextIndex();    // 返回列表中ListIterator所需位置前面元素的索引    int previousIndex();    /* 从列表中删除next()或previous()返回的最后一个元素（有点拗口，    意思就是对迭代器使用hasNext()方法时，删除ListIterator指向位置后面的元素；    当对迭代器使用hasPrevious()方法时，删除ListIterator指向位置前面的元素）*/    void remove();    // 从列表中将next()或previous()返回的最后一个元素返回的最后一个元素更改为指定元素e    void set(E e);    // 将指定的元素插入列表，插入位置为迭代器当前位置之前     void add(E e); }</code></pre><h2 id="7-Listiterator代码实例"><a href="#7-Listiterator代码实例" class="headerlink" title="7.Listiterator代码实例"></a>7.Listiterator代码实例</h2><pre><code>public class PersonTest {    public static void main(String[] args) {        // 创建集合        ArrayList&lt;Person&gt; a = new ArrayList&lt;&gt;();        // 添加对象        a.add(new Person(&quot;苏彦&quot;,20));        a.add(new Person(&quot;苏小彦&quot;,21));        a.add(new Person(&quot;苏大彦&quot;,22));        a.add(new Person(&quot;苏好彦&quot;,23));        // 创建迭代器        ListIterator li = a.listIterator();        System.out.println(&quot;从前往后输出：&quot;);        // 单向从前到后遍历        while(li.hasNext()) {            Person temp1 = (Person)li.next(); // 向下转型            System.out.println(temp1.getName() + &quot; &quot; + temp1.getAge());        }        System.out.println(&quot;从后往前输出：&quot;);        // 可以双向遍历，但是一定要先进行由前往后输出，之后才能进行由后往前的输出        while (li.hasPrevious()) {            Person temp2 = (Person) li.previous();            System.out.println(temp2.getName() +  &quot; &quot; + temp2.getAge());        }    }}从前往后输出：苏彦 20苏小彦 21苏大彦 22苏好彦 23从后往前输出：苏好彦 23苏大彦 22苏小彦 21苏彦 20</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Iterator和ListIterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals方法</title>
      <link href="/2019/11/12/equals-fang-fa/"/>
      <url>/2019/11/12/equals-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Object类之equals方法"><a href="#1-Object类之equals方法" class="headerlink" title="1.Object类之equals方法"></a>1.Object类之equals方法</h3><p> Java源码里面Object中的equals方法: </p><pre><code> public boolean equals(Object obj) {        return (this == obj);    }</code></pre><blockquote><p> Object中的equals方法比较的是两个引用的内存地址。但是在现实的业务逻辑当中，不应该比较内存地址，应该比较地址里面的内容，所以需要对equals方法进行重写。 </p><p> <strong>注意：在使用自己创建的类进行equals比较时，一定要先重写equals方法</strong> </p></blockquote><h2 id="2-equals代码测试"><a href="#2-equals代码测试" class="headerlink" title="2.equals代码测试"></a>2.equals代码测试</h2><pre><code>public class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Person person = (Person) o;        return age == person.age &amp;&amp;                Objects.equals(name, person.name);    }</code></pre><pre><code>public class PersonTest {    public static void main(String[] args) {        // 创建一个Object型的对象        Object o1 = new Object();        Object o2 = new Object();        System.out.println(o1.equals(o2)); // 堆地址不一样        // 创建一个Person对象        Person p1 = new Person(&quot;苏彦&quot;,20);        Person p2 = new Person(&quot;苏彦&quot;,20);        Person p3 = new Person(&quot;苏小彦&quot;,18);        System.out.println(p1.equals(p2));        System.out.println(p1.equals(p3));    }}</code></pre><h2 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3.测试结果"></a>3.测试结果</h2><pre><code>falsetruefalseProcess finished with exit code 0</code></pre><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><blockquote><ul><li>Object中的equals方法比较的是两个引用的内存地址 </li></ul><ul><li><strong>重写了Object类中的equals方法</strong>，比较的是对象的内容 </li></ul><ul><li>比较两个String类型时，不能使用==，要使用equals方法，String已经重写了Object中的equals方法，比较的是内容。 </li></ul><ul><li>== 两边如果是引用类型，则比较内存地址，地址相同则是true,反之则false. </li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> equals方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object类</title>
      <link href="/2019/11/12/object-lei/"/>
      <url>/2019/11/12/object-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h2><blockquote><p> Object类是所有类的父类,即每个类都直接或间接继承自该类。所以一个Object类型的变量可以引用任何对象,不论是类实例还是数组。  在不明确给出父类的情况下,Java会自动把Object作为要定义类的父类。 </p></blockquote><h2 id="2-toString"><a href="#2-toString" class="headerlink" title="2.toString"></a>2.toString</h2><p>Object中的toString方法</p><pre><code>  public String toString() {        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());    }</code></pre><blockquote><p> SUN在Object类中设计toString方法的目的：返回java对象的字符串表示形式。</p><p>  在现实的开发过程中，Object中的toString方法就是要被重写的。 </p><p> Object中的toString方法返回： 类名@java对象的内存地址经过哈希算法得出的int类型值再转换成十六进制.  这个输出结果可以等同看做java对象在堆中的内存地址。 </p></blockquote><pre><code>public class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    // 重写toString()方法    @Override    public String toString() {        return &quot;Person{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><pre><code>public class PersonTest {    public static void main(String[] args) {        // 创建一个Object型的对象        Object object = new Object();        System.out.println(object);        // 创建一个Person对象        Person person = new Person(&quot;苏彦&quot;,20);        // 如果直接打印一个引用类型的对象，系统会默认调用toString()方法        System.out.println(person);        System.out.println(person.toString());    }}</code></pre><pre><code>java.lang.Object@14ae5a5Person{name=&#39;苏彦&#39;, age=20}Person{name=&#39;苏彦&#39;, age=20}Process finished with exit code 0</code></pre><h2 id="3-finalize方法"><a href="#3-finalize方法" class="headerlink" title="3.finalize方法"></a>3.finalize方法</h2><blockquote><p> finalize方法不需要程序员去调用，由<strong>系统自动调用</strong>。java对象如果没有更多的引用指向它，则该java对象成为垃圾数据，等待垃圾回收器的回收，垃圾回收器在回收这个java对象之前会自动调用该对象的finalize方法。finalize方法是该对象马上就要被回收了 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>覆写与重载</title>
      <link href="/2019/11/12/fu-xie-yu-chong-zai/"/>
      <url>/2019/11/12/fu-xie-yu-chong-zai/</url>
      
        <content type="html"><![CDATA[<h2 id="1-覆写"><a href="#1-覆写" class="headerlink" title="1.覆写"></a>1.覆写</h2><blockquote><p>如果父类定义的方法达不到子类的期望，那么子类可以重新实现方法覆盖父类的实现。</p></blockquote><pre><code>public class Father {    public static void main(String[] args) {        Father father = new Son();        father.good();    }    protected void good() {        System.out.println(&quot;叫爸爸&quot;);    }}</code></pre><pre><code>public class Son extends Father {    @Override    public void good() {        System.out.println(&quot;祖安&quot;);    }}</code></pre><h2 id="2-覆写总结"><a href="#2-覆写总结" class="headerlink" title="2.覆写总结"></a>2.覆写总结</h2><blockquote><p><strong>一大两小两同</strong></p><ul><li><strong>一大</strong>：子类的方法访问权限控制符只能相同或变大。</li><li><strong>两小</strong>：子类抛出异常和方法返回值只能变小（或相同），都能够转型成父类对象。子类的返回值、抛出异常，与父类存在继承关系。</li><li><strong>两同</strong>：方法名和参数必须完全相同。</li></ul></blockquote><h2 id="3-重载"><a href="#3-重载" class="headerlink" title="3.重载"></a>3.重载</h2><blockquote><p>在同一个类中，如果多个方法有相同的名字，不同的参数（参数个数、顺序、类型不同），即称为重载。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 覆写 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="/2019/11/10/string-lei/"/>
      <url>/2019/11/10/string-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-String类"><a href="#1-String类" class="headerlink" title="1.String类"></a>1.String类</h2><blockquote><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串 。</p></blockquote><h2 id="2-String为什么不可变"><a href="#2-String为什么不可变" class="headerlink" title="2.String为什么不可变"></a>2.String为什么不可变</h2><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    // String本质是一个char数组，1.9后变成byte数组,节省内存空间的开辟    private final char value[];}</code></pre><blockquote><p> 首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段value是个char[ ]数组，而且是用final修饰的。final修饰的字段创建以后就不可改变。 </p></blockquote><blockquote><p> 有的人以为故事就这样完了，其实没有。因为虽然value是不可变，也只是value这个引用地址不可变。挡不住Array数组是可变的事实 。 也就是说Array变量只是stack上的一个引用，数组的本体结构在heap堆。String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。 </p></blockquote><h2 id="3-字符串常量池"><a href="#3-字符串常量池" class="headerlink" title="3.字符串常量池"></a>3.字符串常量池</h2><blockquote><p>我们声明的字符串会放到一个叫做字符串常量池的地方，这样可以减少内存在使用，字符串常量池是堆的一部分。<strong>使用字符串常量池</strong>。<strong>每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串</strong></p></blockquote><pre><code>public class StringTest {    public static void main(String[] args) {        // Java 程序中的所有字符串字面值（如&quot;suyan&quot;）都作为String的对象。        String s1 = &quot;suYan&quot;;        String s2 = &quot;suYan&quot;;        // 不建议这种写法，浪费堆内存        String s3 = new String(&quot;suYan&quot;);        String s4 = new String(&quot;allRight&quot;);        System.out.println(s1 == s2);        System.out.println(s1 == s3);        // String类重写了equals()方法，比较的是两个对象的内容        System.out.println(s1.equals(s3));    }}</code></pre><pre><code>truefalsetrueProcess finished with exit code 0</code></pre><h2 id="4-String类常用方法"><a href="#4-String类常用方法" class="headerlink" title="4.String类常用方法"></a>4.String类常用方法</h2><pre><code>public class StringTest {    public static void main(String[] args) {        String s = &quot;suYan&quot;;        // char charAt(int index); 获取index位置的字符        System.out.println(s.charAt(3));        // boolean contains(CharSequence s); 判断字符串是否包含某个字符串        System.out.println(s.contains(&quot;suY&quot;));        // boolean endsWith(String endStr); 判断是否是已某个字符串结尾        System.out.println(s.endsWith(&quot;an&quot;));        // boolean equalsIgnoreCase(String anotherString); 忽略大小写比较两个字符串是否相等        System.out.println(s.equalsIgnoreCase(&quot;sUYAn&quot;));        // byte getBytes(); 转换成byte数组        String s1 = &quot;goodBoy&quot;;        byte [] array1 = s1.getBytes();        for (int i=0; i &lt; array1.length;i++) {            System.out.println(array1[i] + &quot; &quot;);        }        // int indexOf(); 取指定字符在字符串中的位置        System.out.println(s1.indexOf(&quot;B&quot;));        // int indexOf(String str, int fromIndexOf);从指定的下标开始取得指定字符在字符串的位置        System.out.println(s1.indexOf(&quot;y&quot;,1));        // int lastIndexOf(String str); 从后面开始取得指定字符在字符串最后出现的位置        System.out.println(s1.lastIndexOf(&quot;o&quot;));        // int lastIndexOf(String str, int fromIndex); 从后面指定的下标开始取得指定字符在字符串最后出现的位置        System.out.println(s1.lastIndexOf(&quot;d&quot;,5));        // int length()获取字符串的长度        System.out.println(s1.length());        String s2 = &quot;hello&quot;;        // String replaceALL(String str1 String str2); str2替换字符串中str1的内容        System.out.println(s2.replaceAll(&quot;llo&quot;,&quot;www&quot;));        // String[] split(String s); 根据指定的表达式拆分字符串        String s3 = &quot;a,b,c,d&quot;;        String[] array2 = s3.split(&quot;,&quot;);        for (int i=0; i &lt; array2.length;i++) {            System.out.println(array2[i] + &quot; &quot;);        }        // boolean startsWith(String s); 判断是否以某个字符串开始        System.out.println(s2.startsWith(&quot;he&quot;));        // String substring(int begin); 根据传入的索引位置截取字符串        System.out.println(s2.substring(2));        // String substring(int beginIndex, int endIndex); 根据传入的起始和结束位置截字符串        System.out.println(s2.substring(0,3));        // char[] toCharArray(); 将字符串转换为char数组        String s5 = &quot;eclipse&quot;;        char[] array3 = s5.toCharArray();        for (int i=0; i &lt; array3.length;i++) {            System.out.println(array3[i] + &quot; &quot;);        }        // void toUpperCase();转换成大写        System.out.println(s2.toUpperCase());        // void toLowerCase(); 转换成小写        System.out.println(s2.toLowerCase());        // String trim(); 去除首尾空格        String s4 = &quot; may &quot;;        System.out.println(s4.trim());        // String valueOf(Object ob); 将其他类型转换为字符串类型        Object ob = new Object();        ob = null;        // System.out.println(ob.toString()); 报空指针异常        System.out.println(String.valueOf(ob));    }}</code></pre><pre><code>代码运行结果：atruetruetrue103 111 111 100 66 111 121 46537hewwwa b c d truellohele c l i p s e HELLOhellomaynullProcess finished with exit code 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2019/11/09/duo-tai/"/>
      <url>/2019/11/09/duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是多态"><a href="#1-什么是多态" class="headerlink" title="1.什么是多态"></a>1.什么是多态</h2><blockquote><p>多态是同一行为具有不同表现形式或形态的能力。即对象多种表现形式的体现，就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时的不确定，而是在程序运行期间确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底时哪个类中实现的方法，必须在由程序运行期间才能决定。</p></blockquote><h2 id="2-多态通俗的简介"><a href="#2-多态通俗的简介" class="headerlink" title="2.多态通俗的简介"></a>2.多态通俗的简介</h2><blockquote><p> 多态就是事物存在的多种形态，比如你在大街上看见一只藏獒，你可以说这只藏獒真凶猛，也可以说这只狗真凶猛，还可以说这个动物真凶猛，以上三种说法其实都是指的这只藏獒。</p><p>  在Java里面，也是存在多态的，只要全部符合下面这三种情况，就是多态 </p><ul><li>有继承</li><li>有重写方法</li><li>有父类引用指向子类对象</li></ul></blockquote><h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3.代码示例"></a>3.代码示例</h2><h3 id="3-1父类Animal"><a href="#3-1父类Animal" class="headerlink" title="3.1父类Animal"></a>3.1父类Animal</h3><pre><code>public class Animal {    public int age = 10;    public void eat() {        System.out.println(&quot;动物父类&quot;);    }}</code></pre><h3 id="3-2子类Cat"><a href="#3-2子类Cat" class="headerlink" title="3.2子类Cat"></a>3.2子类Cat</h3><pre><code>public class Cat extends Animal {    public int age = 5;    @Override    public void eat() {        System.out.println(&quot;猫吃老鼠&quot;);    }    // Cat类自己的方法    public void sleep() {        System.out.println(&quot;猫在睡觉&quot;);    }}</code></pre><h3 id="3-3测试类"><a href="#3-3测试类" class="headerlink" title="3.3测试类"></a>3.3测试类</h3><pre><code>public class AnimalTest {    public static void main(String[] args) {        Cat cat = new Cat();        cat.eat();        System.out.println(&quot;猫的年龄是：&quot; + cat.age);        // 父类引用指向子类对象        Animal animal = new Cat();        animal.eat();        // 想执行Cat中的sleep()方法，需要向下强制转型        ((Cat) animal).sleep();        // 父类引用访问成员变量        System.out.println(&quot;动物的年龄：&quot; + animal.age);    }}</code></pre><h3 id="3-4测试结果"><a href="#3-4测试结果" class="headerlink" title="###3.4测试结果"></a>###3.4测试结果</h3><pre><code>猫吃老鼠猫的年龄是：5猫吃老鼠猫在睡觉动物的年龄：10</code></pre><h2 id="4-总结分析"><a href="#4-总结分析" class="headerlink" title="4.总结分析"></a>4.总结分析</h2><blockquote><p><strong>父类引用执行方法调用：</strong> 父类 父类的引用 = (指向) 子类的实例</p><p>当父类的引用要执行方法1的时候，他只会跟他指向的对象说，“嗨，哥们，执行一下你的方法1”然后他就不管了，继续睡大觉去了。然后真实的对象实例就会低头看看写在自己身上的方法1，捏出来执行一把。这个时候如果子类对象重写了方法1，捏出来的就是重写的方法。如果没重写，就会找他爸，从他爸身上去捏方法1出来。这就是所谓的<strong>动态绑定</strong>。</p></blockquote><blockquote><p><strong>成员属性的特别之处</strong></p><p> 如果父类、子类定义了相同名字的成员属性， 只取决于<strong>引用的定义类型。</strong>比如Animal的年龄初始化是10，Cat的年龄的初始化是5 </p><p>父类 obj = new 子类()；// obj.age == 5</p><p>子类 obj2 = new 子类()；// obj.age == 10</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2019/11/09/fan-xing/"/>
      <url>/2019/11/09/fan-xing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类</title>
      <link href="/2019/11/08/lei/"/>
      <url>/2019/11/08/lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><blockquote><p>定义：类是一组相关的属性和行为的集合，类一般都是泛指某一种事物。</p><p>实例对象：对象就是该事物的具体表现。</p></blockquote><h2 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2.内部类"></a>2.内部类</h2><blockquote><p>定义：在一个类的内部定义另外一个类。</p><p>特点：内部类可以直接访问外部类的成员，包括private修饰的变量和方法。</p></blockquote><ul><li>静态内部类</li><li>匿名内部类</li><li>成员内部类</li><li>局部内部类</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一切皆对象</title>
      <link href="/2019/11/08/java-yi-qie-jie-dui-xiang/"/>
      <url>/2019/11/08/java-yi-qie-jie-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象编程思想"><a href="#1-面向对象编程思想" class="headerlink" title="1.面向对象编程思想"></a>1.面向对象编程思想</h2><blockquote><p>把所有的有形或无形的事物都看作对象，并给对象赋予相应的属性和行为，建立对象之间的联系，使程序更加立体、形象地解决编程领域的问题。</p></blockquote><h2 id="2-类的关系"><a href="#2-类的关系" class="headerlink" title="2.类的关系"></a>2.类的关系</h2><table><thead><tr><th>类的关系</th><th>描述</th><th>具体实现</th></tr></thead><tbody><tr><td>继承</td><td>父类与子类的关系</td><td>extends ( is-a )</td></tr><tr><td>实现</td><td>接口与实现类之间的关系</td><td>implements ( can-do )</td></tr><tr><td>组合</td><td>整体和部分的同生共死的关系，两者完全不可分，具有相同的生命周期</td><td>类是成员变量 ( contains-a )</td></tr><tr><td>聚合</td><td>整体和部分暂时组合在一起，两者可独立存在</td><td>类是成员变量 ( has -a )</td></tr><tr><td>依赖</td><td>一个类用到另外一个类</td><td>import类 ( use -a )</td></tr></tbody></table><blockquote><p>类关系中的组合是一种完全绑定的关系，所有成员共同完成一件使命，它们的生命周期是一样的。组合体现的是整体和部分的关系，同生共死，部分不能在整体之间共享。</p></blockquote><blockquote><p>聚合是一种可以拆分的整体和部分的关系，是一种非常松散的暂时组合，部分可以拆出来给另一个整体。</p></blockquote><blockquote><p>依赖是除组合和聚合的类与类之间的关系，这个类只要import，那就是依赖关系。</p></blockquote><h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h2><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {}</code></pre><pre><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;{// 抽象方法，没有方法体 abstract public E get(int index);// 普通方法public boolean add(E e) {        add(size(), e);        return true;    }}</code></pre><blockquote><p>抽象类是对同类事物相对具体的抽象，通常包括抽象方法、普通方法、属性变量。抽象类是对整个类抽象，包括类的属性和行为。设计抽象类是自下而上的过程，我子类需要，所以我定义抽象类。</p></blockquote><h2 id="4接口"><a href="#4接口" class="headerlink" title="4接口"></a>4接口</h2><pre><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {// 抽象方法 int size(); // 默认方法，@since 1.8    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})    default void sort(Comparator&lt;? super E&gt; c) {        Object[] a = this.toArray();        Arrays.sort(a, (Comparator) c);        ListIterator&lt;E&gt; i = this.listIterator();        for (Object e : a) {            i.next();            i.set((E) e);        }    }    // 静态方法 接口的静态方法只能由接口来调用，它不属于实现了那个接口接口的对象，对象调用不到。    static void staticSuYan() {    System.out.println(&quot;接口中的静态方法&quot;)    }    // 接口中成员变量默认是public static final,可以省略这些修饰符    public static final int susu = 20;}</code></pre><blockquote><p>设计接口是自上而下的过程，我接口规范某一行为，我某类需要这个行为，我实现某接口。</p></blockquote><h2 id="5-抽象类和接口的相同点和不同的"><a href="#5-抽象类和接口的相同点和不同的" class="headerlink" title="5.抽象类和接口的相同点和不同的"></a>5.抽象类和接口的相同点和不同的</h2><blockquote><ul><li>在java中，抽象类和接口都不能直接进行实例化，如果要实例化，抽象类引用变量必须指向实现所有抽象方法的子类对象。接口引用变量必须指向实现所有接口方法的类对象。</li><li>抽象类要被子类继承，接口要被类实现。</li><li>接口只能做方法的声明，抽象类既可以做方法声明，还可以做方法实现。</li><li>类只能单继承。</li><li>类或接口可以继承接口，并且可以继承多个接口。</li><li>接口要被类实现，类可以实现多个接口。</li><li>接口中的变量只能是静态的公共变量，抽象类中的变量是普通的变量，即常量。 </li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
